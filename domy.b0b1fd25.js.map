{"version":3,"sources":["node_modules/domy-lang/bin/utils.js","node_modules/domy-lang/bin/lexer.js","node_modules/domy-lang/bin/parser.js","node_modules/domy-lang/bin/interpreter.js","domy.js"],"names":["types","terop","binop","unop","paren","brack","comma","assign","saved","name","tokenTypes","expr","ternary","inv","block","loop","func","term","id","uno","and","xor","or","test","varDec","varAss","std","words","reserved","Set","operators","unaryOperators","binaryOperators","order","Map","ops","isIrrelevant","c","isComment","isOperator","has","isDoubleOperator","n","isParenthesis","isBracket","isComma","isEqual","alphabet","isAlphabetic","match","word","isWord","printError","fileContent","t","s","r","from","to","start","end","console","error","length","rightTrim","slice","trimRight","trimmed","trimLeft","offset","line","blank","repeat","Scope","parent","vars","current","value","get","undefined","set","search","DomyLexer","record","text","i","row","col","tokens","addToken","type","push","cur","Error","past","str","Infinity","table","DomyParser","results","parseError","peek","advance","left","right","statement","cond","args","arg_list","inv_list","not","expression","parseProgram","log","JSON","stringify","DomyInterpreter","global","add","arg","tree","evaluate","node","scope","terminal","identifier","ternaryOperation","unaryOperation","andExpression","xorExpression","orExpression","comparison","variableDeclaration","variableAssignment","parenthesisGroup","functionInvocation","blockGroup","reservedWord","loopGroup","functionDeclaration","find","ret","validate","declaration","assignment","reassign","v","values","next","window","runCode","editor","getValue","lexer","tokenize","parser","parse","pop","replace","document","createElement","getElementById","replaceWith","runner","out","innerHTML","appendChild","run","style"],"mappings":"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","file":"domy.b0b1fd25.js","sourceRoot":"..","sourcesContent":["// Types\nexport const types = {\n    terop: 'ternary:operator',\n    binop: 'binary:operator',\n    unop: 'unary:operator',\n    paren: 'parenthesis:',\n    brack: 'parenthesis:',\n    comma: 'comma',\n    assign: 'assignment',\n    saved: 'reserved',\n    name: 'word'\n};\nexport const tokenTypes = {\n    expr: 'expression',\n    ternary: 'ternary-operation',\n    inv: 'function-invocation',\n    block: 'block',\n    saved: 'reserved',\n    loop: 'while-loop',\n    func: 'function-declaration',\n    term: 'terminal',\n    paren: 'parenthesis',\n    id: 'identifier',\n    uno: 'unary-operation',\n    and: 'and',\n    xor: 'xor',\n    or: 'or',\n    test: 'test',\n    varDec: 'variable-declaration',\n    varAss: 'variable-assignment',\n    std: 'std'\n};\n\n// Reserved Words\nexport const words = [\n    'true',\n    'false',\n    'my',\n    'do',\n    'while',\n    'return',\n    'break',\n    'continue',\n];\nexport const reserved = new Set(words);\n\n// Operators\nexport const operators = [\n    '?',\n    ':',\n    '!=',\n    '==',\n    '|',\n    '^',\n    '&',\n    '!',\n];\nexport const unaryOperators = [\n    '!'\n];\nexport const binaryOperators = [\n    '!=',\n    '==',\n    '|',\n    '^',\n    '&',\n];\nexport const order = new Map([\n    ['?', 40],\n    [':', 40],\n    ['!=', 50],\n    ['==', 50],\n    ['|', 60],\n    ['^', 70],\n    ['&', 80],\n    ['!', 90]\n]);\nexport const ops = new Set(operators);\n\n// Utility Functions\nexport const isIrrelevant = c => c <= ' ' || c === ';';\nexport const isComment = c => c === '#';\nexport const isOperator = c => ops.has(c);\nexport const isDoubleOperator = (c, n) =>\n    (c === '!' || c === '=') && n === '=';\nexport const isParenthesis = c => c === '(' || c === ')';\nexport const isBracket = c => c === '{' || c === '}';\nexport const isComma = c => c === ',';\nexport const isEqual = c => c === '=';\nexport const alphabet = /^[a-zA-Z]$/;\nexport const isAlphabetic = c => c.match(alphabet);\nexport const word = /^[-_a-zA-Z0-9]$/;\nexport const isWord = c => c && c.match(word);\n\n// Error\nexport const printError = (fileContent, t, s, r, c, from, to) => {\n    console.error(`${t} Error: ${s} at row ${r}, col ${c}.`);\n    let start, end;\n    for (start = from; start >= 0; start--)\n        if (fileContent[start] === '\\n')\n            break;\n    for (end = to; end < fileContent.length; end++)\n        if (fileContent[end] === '\\n')\n            break;\n    const rightTrim =\n        fileContent\n            .slice(start + 1, end)\n            .trimRight();\n    const trimmed = rightTrim.trimLeft();\n    const offset = c - (rightTrim.length - trimmed.length);\n    const line = `${r}: `;\n    const blank = ' '.repeat(line.length + offset - 1);\n    console.error(`${line}${trimmed}...`);\n    console.error(`${blank}^`);\n    console.error(`${blank}${c}`);\n};\n\nexport class Scope {\n\n    constructor(parent) {\n        this.parent = parent;\n        this.vars = new Map();\n    }\n\n    find(name) {\n        let current = this;\n        while (current !== null) {\n            const value = current.vars.get(name);\n            if (value !== undefined)\n                return value;\n            current = current.parent;\n        }\n        return undefined;\n    }\n\n    add(name, value) {\n        this.vars.set(name, value);\n    }\n\n    reassign(name, value) {\n        let current = this;\n        while (current !== null) {\n            const search = current.vars.get(name);\n            if (search !== undefined)\n                return current.vars.set(name, value);\n            current = current.parent;\n        }\n        return undefined;\n    }\n\n}\n","import {\n\ttypes,\n\treserved,\n\tisIrrelevant,\n\tisComment,\n\tisOperator,\n\tisDoubleOperator,\n\tisParenthesis,\n\tisBracket,\n\tisComma,\n\tisEqual,\n\tisAlphabetic,\n\tisWord,\n\tprintError\n} from './utils.js';\n\nexport default class DomyLexer {\n\n\tconstructor() {\n\t\t// Record of all Lexes\n\t\tthis.record = [];\n\t}\n\n\ttokenize(text) {\n\t\t// State\n\t\tlet i = 0;\n\t\tlet row = 1;\n\t\tlet col = 1;\n\n\t\t// Tokens\n\t\tconst tokens = [];\n\t\tconst addToken = (text, type, from, to, row, col) =>\n\t\t\ttokens.push({ text, type, from, to, row, col });\n\n\t\t// Text Traversal\n\t\twhile (i < text.length) {\n\t\t\tconst c = text[i];\n\t\t\tif (isIrrelevant(c)) { // Ignore Whitespace and ;\n\t\t\t\tif (c === '\\n') {\n\t\t\t\t\trow++;\n\t\t\t\t\tcol = 0;\n\t\t\t\t}\n\t\t\t} else if (isComment(c)) { // Single Line Comment #\n\t\t\t\tlet cur = text[i];\n\t\t\t\twhile (cur !== '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tcur = text[i];\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\tcol = 0;\n\t\t\t} else if (isDoubleOperator(c, text[i + 1])) { // ==, !=\n\t\t\t\taddToken(\n\t\t\t\t\t`${c}=`,\n\t\t\t\t\ttypes.binop,\n\t\t\t\t\ti,\n\t\t\t\t\ti + 2,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t\ti++;\n\t\t\t\tcol++;\n\t\t\t} else if (isOperator(c)) { // :, &, |, ^, ?, !\n\t\t\t\tconst type =\n\t\t\t\t\tc === '?' || c === ':'\n\t\t\t\t\t\t? types.terop\n\t\t\t\t\t\t: c === '!'\n\t\t\t\t\t\t\t? types.unop\n\t\t\t\t\t\t\t: types.binop;\n\t\t\t\taddToken(\n\t\t\t\t\tc,\n\t\t\t\t\ttype,\n\t\t\t\t\ti,\n\t\t\t\t\ti + 1,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t} else if (isEqual(c)) { // =\n\t\t\t\taddToken(\n\t\t\t\t\tc,\n\t\t\t\t\ttypes.assign,\n\t\t\t\t\ti,\n\t\t\t\t\ti + 1,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t} else if (isParenthesis(c)) { // (, )\n\t\t\t\taddToken(\n\t\t\t\t\tc,\n\t\t\t\t\t`${types.paren}${c === '(' ? 'left' : 'right'}`,\n\t\t\t\t\ti,\n\t\t\t\t\ti + 1,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t} else if (isBracket(c)) { // {, }\n\t\t\t\taddToken(\n\t\t\t\t\tc,\n\t\t\t\t\t`${types.brack}${c === '{' ? 'left' : 'right'}`,\n\t\t\t\t\ti,\n\t\t\t\t\ti + 1,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t} else if (isComma(c)) { // ,\n\t\t\t\taddToken(\n\t\t\t\t\tc,\n\t\t\t\t\ttypes.comma,\n\t\t\t\t\ti,\n\t\t\t\t\ti + 1,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t} else if (isAlphabetic(c)) { // Words\n\t\t\t\tlet past = i;\n\t\t\t\tlet str = '';\n\t\t\t\tlet cur = text[i];\n\t\t\t\twhile (isWord(cur)) {\n\t\t\t\t\tstr += cur;\n\t\t\t\t\ti++;\n\t\t\t\t\tcur = text[i];\n\t\t\t\t}\n\t\t\t\tconst type = reserved.has(str)\n\t\t\t\t\t? types.saved\n\t\t\t\t\t: types.name;\n\t\t\t\taddToken(\n\t\t\t\t\tstr,\n\t\t\t\t\ttype,\n\t\t\t\t\tpast,\n\t\t\t\t\ti--,\n\t\t\t\t\trow,\n\t\t\t\t\tcol\n\t\t\t\t);\n\t\t\t\tcol += i - past;\n\t\t\t} else { // No Match\n\t\t\t\tprintError(text, 'Lexer', `Unable to lex ${c}`, row, col, i, i);\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\ti++;\n\t\t\tcol++;\n\t\t}\n\n\t\t// Add End Token\n\t\taddToken(\n\t\t\t'(end)',\n\t\t\ttypes.saved,\n\t\t\t-1,\n\t\t\ttext.length,\n\t\t\tInfinity,\n\t\t\tInfinity\n\t\t);\n\n\t\t// Save to record\n\t\tthis.record.push(tokens);\n\n\t\t// Return tokens\n\t\treturn tokens;\n\t}\n\n\ttoString() {\n\t\tconst options = [\n\t\t\t'text',\n\t\t\t'row',\n\t\t\t'col'\n\t\t];\n\t\tconsole.table(this.record[this.record.length - 1], options);\n\t}\n\n}\n","import { types, tokenTypes, printError } from './utils.js';\n\nexport default class DomyParser {\n\n    constructor() {\n        // Record of all Parses\n        this.record = [];\n    }\n\n    parse(tokens, text) {\n\n        // State\n        let i = 0;\n        const results = [];\n\n        // Utility Functions\n        const parseError = s => {\n            const { from, to, row, col } = peek();\n            printError(text, 'Parser', s, row, col, from, to);\n            throw new Error();\n        };\n        const advance = (c, t) => {\n            const { text, type } = tokens[i];\n            if (c && c !== text)\n                parseError(`Expected '${c}' but got '${text}'`);\n            if (t && t !== type)\n                parseError(`Expected '${t}' but got '${type}'`);\n            return tokens[i++];\n        };\n        const peek = (offset = 0) => {\n            return tokens[i + offset] ? tokens[i + offset] : { text: '' };\n        };\n\n        // EBNF Grammar Functions\n        const term = () => {\n            const { text, type } = peek();\n            if (text === 'true') {\n                advance('true');\n                return {\n                    type: tokenTypes.term,\n                    value: true\n                };\n            } else if (text === 'false') {\n                advance('false');\n                return {\n                    type: tokenTypes.term,\n                    value: false\n                };\n            } else if (text === '(') {\n                advance('(');\n                const value = statement();\n                advance(')');\n                if (peek().text !== '?') {\n                    return {\n                        type: tokenTypes.paren,\n                        value\n                    };\n                }\n                advance('?');\n                let left;\n                if (peek().text === '{') {\n                    left = block();\n                } else {\n                    left = statement();\n                }\n                advance(':');\n                let right;\n                if (peek().text === '{') {\n                    right = block();\n                } else {\n                    right = statement();\n                }\n                return {\n                    type: tokenTypes.ternary,\n                    cond: value,\n                    left,\n                    right\n                };\n            } else if (text === 'return') {\n                advance('return');\n                if (peek().text !== '}')\n                    return {\n                        type: tokenTypes.saved,\n                        text,\n                        value: statement()\n                    };\n                else\n                    return {\n                        type: tokenTypes.saved,\n                        text,\n                    };\n            } else if (text === 'continue') {\n                advance('continue');\n                return {\n                    type: tokenTypes.saved,\n                    text,\n                };\n            } else if (text === 'break') {\n                advance('break');\n                return {\n                    type: tokenTypes.saved,\n                    text,\n                };\n            } else if (text === 'while') {\n                advance('while');\n                const cond = statement();\n                const value = block();\n                return {\n                    type: tokenTypes.loop,\n                    cond,\n                    value\n                };\n            } else if (text === 'do') {\n                advance('do');\n                const args = arg_list();\n                const value = block();\n                return {\n                    type: tokenTypes.func,\n                    args,\n                    value\n                };\n            } else if (text === '{') {\n                return block();\n            } else if (type === types.name) {\n                const name = advance(null, types.name);\n                if (peek().text === '(') {\n                    const args = inv_list();\n                    return {\n                        type: tokenTypes.inv,\n                        name: name.text,\n                        args\n                    };\n                }\n                return {\n                    type: tokenTypes.id,\n                    name: name.text\n                };\n            } else if (text === '(end)') {\n                parseError('Reached end of input');\n            } else parseError('Term could not be parsed');\n        };\n        const not = () => {\n            if (peek().text === '!') {\n                advance('!');\n                const value = term();\n                return {\n                    type: tokenTypes.uno,\n                    value\n                };\n            } else return term();\n        };\n        const and = () => {\n            const left = not();\n            if (peek().text === '&') {\n                advance('&');\n                const right = and();\n                return {\n                    type: tokenTypes.and,\n                    left,\n                    right\n                };\n            } else return left;\n        };\n        const xor = () => {\n            const left = and();\n            if (peek().text === '^') {\n                advance('^');\n                const right = xor();\n                return {\n                    type: tokenTypes.xor,\n                    left,\n                    right\n                };\n            } else return left;\n        };\n        const or = () => {\n            const left = xor();\n            if (peek().text === '|') {\n                advance('|');\n                const right = or();\n                return {\n                    type: tokenTypes.or,\n                    left,\n                    right\n                };\n            } else return left;\n        };\n        const expression = () => {\n            const left = or();\n            if (peek().text === '==') {\n                advance('==');\n                const right = expression();\n                return {\n                    type: tokenTypes.test,\n                    value: '==',\n                    left,\n                    right\n                };\n            } else if (peek().text === '!=') {\n                advance('!=');\n                const right = expression();\n                return {\n                    type: tokenTypes.test,\n                    value: '!=',\n                    left,\n                    right\n                };\n            } else return left;\n        };\n        const inv = () => {\n            return statement();\n        };\n        const inv_list = () => {\n            const args = [];\n            advance('(');\n            while (peek().text !== ')') {\n                args.push(inv());\n                if (peek().text === ',')\n                    advance(',');\n            }\n            advance(')');\n            return args;\n        };\n        const arg_list = () => {\n            const args = [];\n            advance('(');\n            while (peek().text !== ')') {\n                args.push(advance(null, types.name));\n                if (peek().text === ',')\n                    advance(',');\n            }\n            advance(')');\n            return args;\n        };\n        const block = () => {\n            const value = [];\n            advance('{');\n            while (peek().text !== '}') {\n                value.push(statement());\n            }\n            advance('}');\n            return {\n                type: tokenTypes.block,\n                value\n            };\n        };\n        const statement = () => {\n            if (peek().text === 'my') {\n                advance('my');\n                const name = advance(null, types.name);\n                advance('=');\n                const value = statement();\n                return {\n                    type: tokenTypes.varDec,\n                    name: name.text,\n                    value\n                };\n            } else if (peek(1).text === '=') {\n                const name = advance(null, types.name);\n                advance('=');\n                const value = statement();\n                return {\n                    type: tokenTypes.varAss,\n                    name: name.text,\n                    value\n                };\n            } else return expression();\n        };\n        const parseProgram = () => {\n            while (peek().text !== '(end)')\n                results.push(statement());\n        };\n\n        // Parse Program\n        parseProgram();\n\n        // Save to Record\n        this.record.push(results);\n\n        // Return Statements\n        return results;\n    }\n\n    toString() {\n        const options = [\n            'type',\n            'name',\n            'text',\n            'args',\n            'cond',\n            'left',\n            'right',\n            'result',\n            'value',\n        ];\n        console.log(JSON.stringify(\n            this.record[this.record.length - 1],\n            options,\n            '  |'\n        ));\n    }\n\n}\n","import { tokenTypes, Scope } from './utils.js';\n\nexport default class DomyInterpreter {\n\n    constructor() {\n        this.global = new Scope(null);\n        this.global.add('print', {\n            type: tokenTypes.std,\n            args: ['toPrint'],\n            value: arg => {\n                console.log(JSON.stringify(\n                    arg.type === tokenTypes.func\n                        ? arg\n                        : arg.value,\n                    [\n                        'name', 'text', 'type', 'args',\n                        'value', 'cond', 'left', 'right'\n                    ],\n                    2\n                ));\n                return { value: true };\n            }\n        });\n    }\n\n    run(tree) {\n        for (const statement of tree)\n            this.evaluate(statement, this.global);\n    }\n\n    evaluate(node, scope) {\n        switch (node.type) {\n            case tokenTypes.term:\n                return this.terminal(node, scope);\n            case tokenTypes.id:\n                return this.identifier(node, scope);\n            case tokenTypes.ternary:\n                return this.ternaryOperation(node, scope);\n            case tokenTypes.uno:\n                return this.unaryOperation(node, scope);\n            case tokenTypes.and:\n                return this.andExpression(node, scope);\n            case tokenTypes.xor:\n                return this.xorExpression(node, scope);\n            case tokenTypes.or:\n                return this.orExpression(node, scope);\n            case tokenTypes.test:\n                return this.comparison(node, scope);\n            case tokenTypes.varDec:\n                return this.variableDeclaration(node, scope);\n            case tokenTypes.varAss:\n                return this.variableAssignment(node, scope);\n            case tokenTypes.paren:\n                return this.parenthesisGroup(node, scope);\n            case tokenTypes.inv:\n                return this.functionInvocation(node, scope);\n            case tokenTypes.block:\n                return this.blockGroup(node, scope);\n            case tokenTypes.saved:\n                return this.reservedWord(node, scope);\n            case tokenTypes.loop:\n                return this.loopGroup(node, scope);\n            case tokenTypes.func:\n                return this.functionDeclaration(node, scope);\n            default:\n                throw new Error('Invalid Token Type.');\n        }\n    }\n\n    terminal(node, scope) {\n        return { value: node.value };\n    }\n\n    identifier(node, scope) {\n        return scope.find(node.name);\n    }\n\n    ternaryOperation(node, scope) {\n        if (node.left.type === tokenTypes.saved)\n            throw new Error('Reserved words not allowed in condition');\n        const cond = this.evaluate(node.cond, scope);\n        const { value, type, ret } = this.evaluate(\n            cond.value\n                ? node.left\n                : node.right,\n            scope\n        );\n        return { value: ret || value, type };\n    }\n\n    unaryOperation(node, scope) {\n        if (node.value.type === tokenTypes.saved)\n            throw new Error('Reserved words only allowed in blocks');\n        return {\n            value:\n                !(node.value.type === tokenTypes.block\n                    ? this.validate(this.evaluate(node.value, scope)).value\n                    : this.evaluate(node.value, scope).value)\n        };\n    }\n\n    andExpression(node, scope) {\n        const left = this.evaluate(node.left, scope);\n        if (!left.value)\n            return { value: left.value, type: left.type, ret: left.ret };\n        const right = this.evaluate(node.right, scope);\n        const value = right.ret === undefined\n            ? left.value && right.value\n            : left.value && right.ret;\n        return { value, type: right.type };\n    }\n\n    xorExpression(node, scope) {\n        const left = this.evaluate(node.left, scope);\n        if (left.type)\n            return { value: left.value, type: left.type, ret: left.ret };\n        const right = this.evaluate(node.right, scope);\n        const value = right.ret === undefined\n            ? (left.value && !right.value) || (!left.value && right.value)\n            : (left.value && !right.ret) || (!left.value && right.ret);\n        return { value, type: right.type };\n    }\n\n    orExpression(node, scope) {\n        const left = this.evaluate(node.left, scope);\n        if (left.value || left.type)\n            return { value: left.value, type: left.type, ret: left.ret };\n        const right = this.evaluate(node.right, scope);\n        return { value: right.ret || right.value, type: right.type };\n    }\n\n    comparison(node, scope) {\n        if (node.left.type === tokenTypes.saved ||\n            node.right.type === tokenTypes.saved)\n            throw new Error('Reserved words only allowed in blocks');\n        if (node.value === '==') return {\n            value:\n                (node.left.type === tokenTypes.block\n                    ? this.validate(this.evaluate(node.left, scope)).value\n                    : this.evaluate(node.left, scope).value) ===\n                (node.right.type === tokenTypes.block\n                    ? this.validate(this.evaluate(node.right, scope)).value\n                    : this.evaluate(node.right, scope).value)\n        };\n        else return {\n            value:\n                (node.left.type === tokenTypes.block\n                    ? this.validate(this.evaluate(node.left, scope)).value\n                    : this.evaluate(node.left, scope).value) !==\n                (node.right.type === tokenTypes.block\n                    ? this.validate(this.evaluate(node.right, scope)).value\n                    : this.evaluate(node.right, scope).value)\n        };\n    }\n\n    variableDeclaration(node, scope) {\n        if (node.value.type === tokenTypes.saved)\n            throw new Error('Reserved words only allowed in blocks');\n        const declaration = scope.find(node.name);\n        if (declaration !== undefined)\n            throw new Error(`${node.name} is already defined.`);\n        scope.add(\n            node.name,\n            node.value.type === tokenTypes.block\n                ? this.validate(this.evaluate(node.value, scope))\n                : this.evaluate(node.value, scope)\n        );\n        return { value: true };\n    }\n\n    variableAssignment(node, scope) {\n        if (node.value.type === tokenTypes.saved)\n            throw new Error('Reserved words only allowed in blocks');\n        const assignment = scope.find(node.name);\n        if (assignment === undefined)\n            throw new Error(`${node.name} is undefined.`);\n        scope.reassign(\n            node.name,\n            node.value.type === tokenTypes.block\n                ? this.validate(this.evaluate(node.value, scope))\n                : this.evaluate(node.value, scope)\n        );\n        return { value: true };\n    }\n\n    validate(v) {\n        const { value, type, ret } = v;\n        if (type === 'return' && ret !== undefined)\n            return ret;\n        else if (type !== undefined)\n            throw new Error(`Invalid type: ${type}.`);\n        else\n            return { value };\n    }\n\n    parenthesisGroup(node, scope) {\n        if (node.value.type === tokenTypes.saved)\n            throw new Error('Reserved words only allowed in blocks');\n        return this.evaluate(node.value, scope);\n    }\n\n    functionInvocation(node, scope) {\n        const func = scope.find(node.name);\n        if (func === undefined)\n            throw new Error(`Function ${node.name} is not defined.`);\n        if (func.args.length !== node.args.length)\n            throw new Error(`Argument Length does not match.`);\n        if (func.type === tokenTypes.std) {\n            const values = [];\n            for (const arg of node.args) {\n                values.push(\n                    arg.type === tokenTypes.id\n                        ? scope.find(arg.name)\n                        : arg.type === tokenTypes.block\n                            ? this.validate(this.evaluate(arg.value, scope))\n                            : this.evaluate(\n                                arg.value !== undefined\n                                    ? arg.value\n                                    : arg,\n                                scope)\n                );\n            }\n            return this.validate(func.value(...values));\n        } else {\n            const next = new Scope(scope);\n            for (let i = 0; i < func.args.length; i++) {\n                next.add(\n                    func.args[i].text,\n                    node.args[i].type === tokenTypes.id\n                        ? scope.find(node.args[i].text)\n                        : node.args[i].type === tokenTypes.block\n                            ? this.validate(this.evaluate(node.args[i], scope))\n                            : this.evaluate(node.args[i], scope)\n                );\n            }\n            return this.validate(this.evaluate(func.value, next));\n        }\n    }\n\n    blockGroup(node, scope) {\n        const next = new Scope(scope);\n        for (const statement of node.value) {\n            const { value, type, ret } = this.evaluate(statement, next);\n            if (type !== undefined)\n                return { value, type, ret };\n        }\n        return { value: true };\n    }\n\n    reservedWord(node, scope) {\n        if (node.text === 'return')\n            return {\n                value: true, type: 'return',\n                ret:\n                    node.value !== undefined\n                        ? node.value.type === tokenTypes.block\n                            ? this.validate(this.evaluate(node.value, scope))\n                            : this.evaluate(node.value, scope)\n                        : undefined\n            };\n        if (node.text === 'continue')\n            return { value: true, type: 'continue' };\n        if (node.text === 'break')\n            return { value: true, type: 'break' };\n    }\n\n    loopGroup(node, scope) {\n        if (node.cond.type === tokenTypes.saved)\n            throw new Error('Reserved words only allowed in blocks');\n        while (true) {\n            const cond = node.cond.type === tokenTypes.block\n                ? this.validate(this.evaluate(node.cond, scope))\n                : this.evaluate(node.cond, scope);\n            if (!cond.value)\n                break;\n            const next = new Scope(scope);\n            const { value, type, ret } = this.evaluate(node.value, next);\n            if (type === 'return')\n                return { value: ret !== undefined ? ret : value };\n            if (type === 'break')\n                break;\n            if (type === 'continue')\n                continue;\n        }\n        return { value: true };\n    }\n\n    functionDeclaration(node, scope) {\n        return node;\n    }\n\n}\n","import DomyLexer from '/node_modules/domy-lang/bin/lexer.js';\nimport DomyParser from '/node_modules/domy-lang/bin/parser.js';\nimport DomyInterpreter from '/node_modules/domy-lang/bin/interpreter.js';\nimport { tokenTypes } from '/node_modules/domy-lang/bin/utils.js';\n\nwindow.runCode = function runCode() {\n\n    try {\n\n        // Code\n        const text = editor.getValue();\n\n        // Lexer\n        const lexer = new DomyLexer();\n        lexer.tokenize(text);\n\n        // Parser\n        const parser = new DomyParser();\n        parser.parse(lexer.record.pop(), text);\n\n        // Output\n        const replace = document.createElement('code');\n        replace.id = 'terminal';\n        document.getElementById('terminal').replaceWith(replace);\n\n        // Interpreter\n        const runner = new DomyInterpreter();\n        runner.global.reassign('print', {\n            type: tokenTypes.std,\n            args: ['toPrint'],\n            value: arg => {\n                const out = JSON.stringify(\n                    arg.type === tokenTypes.func\n                        ? arg\n                        : arg.value,\n                    [\n                        'name', 'text', 'type', 'args',\n                        'value', 'cond', 'left', 'right'\n                    ],\n                    2\n                );\n                const node = document.createElement('div');\n                node.innerHTML = out;\n                replace.appendChild(node);\n                return { value: true };\n            }\n        });\n        runner.run(parser.record.pop());\n\n    } catch (error) {\n        const replace = document.getElementById('terminal');\n        const node = document.createElement('div');\n        node.style = 'color: red;'\n        node.innerHTML = `Error Occurred.`;\n        replace.appendChild(node);\n    }\n\n};\n"]}